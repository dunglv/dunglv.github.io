<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>G√≥c T·∫≠p Trung - Focus Zone</title>
    <style>
        :root {
            --primary: #667eea;
            --secondary: #764ba2;
            --bg-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --glass-bg: rgba(255, 255, 255, 0.95);
            --text-color: #333;
            --timer-size: 300px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: var(--bg-gradient);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            color: var(--text-color);
        }

        .container {
            background: var(--glass-bg);
            border-radius: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            width: 100%;
            max-width: 500px;
            padding: 40px;
            text-align: center;
            transition: transform 0.3s ease;
        }

        h1 {
            margin-bottom: 20px;
            font-size: 2em;
            background: var(--bg-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        /* Timer Styles */
        .timer-container {
            position: relative;
            width: var(--timer-size);
            height: var(--timer-size);
            margin: 0 auto 30px;
        }

        .timer-ring {
            transform: rotate(-90deg);
            width: 100%;
            height: 100%;
        }

        .timer-ring circle {
            fill: transparent;
            stroke-width: 10;
            stroke-linecap: round;
        }

        .timer-ring-bg {
            stroke: #e0e0e0;
        }

        .timer-ring-progress {
            stroke: var(--primary);
            stroke-dasharray: 880;
            /* 2 * PI * r (r approx 140) */
            stroke-dashoffset: 0;
            transition: stroke-dashoffset 1s linear;
        }

        .timer-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .time-left {
            font-size: 4em;
            font-weight: bold;
            color: var(--secondary);
            font-variant-numeric: tabular-nums;
        }

        .timer-status {
            font-size: 1.2em;
            color: #666;
            margin-top: 5px;
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 30px;
        }

        .btn {
            border: none;
            padding: 12px 25px;
            border-radius: 50px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 600;
        }

        .btn-primary {
            background: var(--bg-gradient);
            color: white;
            box-shadow: 0 5px 15px rgba(118, 75, 162, 0.4);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(118, 75, 162, 0.6);
        }

        .btn-secondary {
            background: #f0f0f0;
            color: #555;
        }

        .btn-secondary:hover {
            background: #e0e0e0;
        }

        /* Task Input */
        .task-input-group {
            margin-bottom: 30px;
            position: relative;
        }

        .task-input {
            width: 100%;
            padding: 15px;
            border: 2px solid #eee;
            border-radius: 15px;
            font-size: 1rem;
            text-align: center;
            transition: border-color 0.3s;
            outline: none;
        }

        .task-input:focus {
            border-color: var(--primary);
        }

        /* Settings */
        .settings-panel {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .setting-group {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .setting-label {
            font-size: 0.8em;
            color: #666;
            margin-bottom: 5px;
        }

        .setting-input {
            width: 60px;
            padding: 5px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            text-align: center;
            font-size: 1em;
        }

        /* Sound Generator */
        .sound-panel {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 20px;
            margin-top: 20px;
        }

        .sound-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .sound-title {
            font-weight: bold;
            color: #555;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .sound-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        .sound-btn {
            padding: 10px;
            border: 2px solid #eee;
            /* transparent border initially */
            background: white;
            border-radius: 10px;
            cursor: pointer;
            font-size: 0.9em;
            color: #666;
            transition: all 0.2s;
        }

        .sound-btn.active {
            border-color: var(--primary);
            background: rgba(102, 126, 234, 0.1);
            color: var(--primary);
            font-weight: bold;
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 10px;
            color: #666;
            font-size: 0.9em;
        }

        input[type="range"] {
            flex: 1;
            height: 5px;
            background: #ddd;
            border-radius: 5px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 15px;
            height: 15px;
            background: var(--primary);
            border-radius: 50%;
            cursor: pointer;
        }

        /* Back Link */
        .back-link {
            display: inline-block;
            margin-top: 20px;
            color: #666;
            text-decoration: none;
            font-size: 0.9em;
            transition: color 0.2s;
        }

        .back-link:hover {
            color: var(--primary);
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>üéß G√≥c T·∫≠p Trung</h1>

        <div class="task-input-group">
            <input type="text" class="task-input" placeholder="B·∫°n ƒëang t·∫≠p trung l√†m g√¨?" id="taskInput">
        </div>

        <div class="settings-panel">
            <div class="setting-group">
                <label class="setting-label">T·∫≠p trung (ph√∫t)</label>
                <input type="number" class="setting-input" id="focusTimeInput" value="25" min="1" max="180">
            </div>
            <div class="setting-group">
                <label class="setting-label">Ngh·ªâ (ph√∫t)</label>
                <input type="number" class="setting-input" id="breakTimeInput" value="5" min="1" max="60">
            </div>
        </div>

        <div class="timer-container">
            <svg class="timer-ring" width="300" height="300" viewBox="0 0 300 300">
                <circle class="timer-ring-bg" cx="150" cy="150" r="140"></circle>
                <circle class="timer-ring-progress" cx="150" cy="150" r="140" id="progressRing"></circle>
            </svg>
            <div class="timer-display">
                <div class="time-left" id="timeLeft">25:00</div>
                <div class="timer-status" id="timerStatus">S·∫µn s√†ng</div>
            </div>
        </div>

        <div class="controls">
            <button class="btn btn-primary" id="startBtn">B·∫Øt ƒë·∫ßu</button>
            <button class="btn btn-secondary" id="resetBtn">ƒê·∫∑t l·∫°i</button>
        </div>

        <div class="sound-panel">
            <div class="sound-header">
                <div class="sound-title">
                    <span>üîä √Çm thanh n·ªÅn</span>
                </div>
            </div>
            <div class="sound-controls">
                <button class="sound-btn" data-type="white">White</button>
                <button class="sound-btn" data-type="pink">Pink</button>
                <button class="sound-btn" data-type="brown">Brown</button>
            </div>
            <div class="volume-control">
                <span>üîà</span>
                <input type="range" id="volumeSlider" min="0" max="1" step="0.01" value="0.1">
                <span>üîä</span>
            </div>
        </div>

        <a href="index.html" class="back-link">‚Üê Quay l·∫°i ZTools</a>
    </div>

    <script>
        // --- Timer Logic ---
        const FULL_DASH_ARRAY = 2 * Math.PI * 140; // approx 879.6

        let focusTime = 25 * 60;
        let breakTime = 5 * 60;
        let timeLeft = focusTime;
        let isRunning = false;
        let timerInterval = null;
        let isFocusMode = true;

        const timeLeftEl = document.getElementById('timeLeft');
        const timerStatusEl = document.getElementById('timerStatus');
        const startBtn = document.getElementById('startBtn');
        const resetBtn = document.getElementById('resetBtn');
        const progressRing = document.getElementById('progressRing');
        const focusInput = document.getElementById('focusTimeInput');
        const breakInput = document.getElementById('breakTimeInput');

        // Setup Init State
        progressRing.style.strokeDasharray = `${FULL_DASH_ARRAY} ${FULL_DASH_ARRAY}`;
        progressRing.style.strokeDashoffset = 0;

        function updateSettings() {
            focusTime = parseInt(focusInput.value) * 60;
            breakTime = parseInt(breakInput.value) * 60;
            if (!isRunning) {
                timeLeft = isFocusMode ? focusTime : breakTime;
                updateDisplay();
            }
        }

        focusInput.addEventListener('change', updateSettings);
        breakInput.addEventListener('change', updateSettings);

        function formatTime(seconds) {
            const m = Math.floor(seconds / 60);
            const s = seconds % 60;
            return `${m < 10 ? '0' : ''}${m}:${s < 10 ? '0' : ''}${s}`;
        }

        function setCircleProgress(percent) {
            const offset = FULL_DASH_ARRAY - (percent / 100) * FULL_DASH_ARRAY;
            progressRing.style.strokeDashoffset = offset;
        }

        function updateDisplay() {
            timeLeftEl.textContent = formatTime(timeLeft);
            const totalTime = isFocusMode ? focusTime : breakTime;
            const progress = ((totalTime - timeLeft) / totalTime) * 100;

            // Note: Progress ring goes backwards (empties) or forwards (fills)? 
            // Usually Pomodoro timers empty out. Let's make it empty out.
            // percent remaining
            const percentRemaining = (timeLeft / totalTime) * 100;
            const offset = FULL_DASH_ARRAY * (1 - percentRemaining / 100);
            progressRing.style.strokeDashoffset = -offset; // Negative to rotate clockwise empty

            // Update tab title
            document.title = `${formatTime(timeLeft)} - ${isFocusMode ? 'T·∫≠p trung' : 'Ngh·ªâ ng∆°i'}`;
        }

        function toggleTimer() {
            if (isRunning) {
                pauseTimer();
            } else {
                startTimer();
            }
        }

        function startTimer() {
            if (isRunning) return;
            // Lock inputs while running
            focusInput.disabled = true;
            breakInput.disabled = true;

            isRunning = true;
            startBtn.textContent = 'T·∫°m d·ª´ng';
            startBtn.classList.add('active'); // Optional styling

            timerInterval = setInterval(() => {
                if (timeLeft > 0) {
                    timeLeft--;
                    updateDisplay();
                } else {
                    switchMode();
                }
            }, 1000);
        }

        function pauseTimer() {
            isRunning = false;
            clearInterval(timerInterval);
            startBtn.textContent = 'Ti·∫øp t·ª•c';
        }

        function resetTimer() {
            pauseTimer();
            isFocusMode = true;

            // Unlock inputs
            focusInput.disabled = false;
            breakInput.disabled = false;

            // Re-read settings just in case
            focusTime = parseInt(focusInput.value) * 60;
            breakTime = parseInt(breakInput.value) * 60;

            timeLeft = focusTime;
            timerStatusEl.textContent = 'S·∫µn s√†ng';
            startBtn.textContent = 'B·∫Øt ƒë·∫ßu';
            updateDisplay();
        }

        function switchMode() {
            pauseTimer();
            // Play notification sound (simple beep)
            playSoundNotification();

            if (isFocusMode) {
                isFocusMode = false;
                timeLeft = breakTime;
                timerStatusEl.textContent = '‚òï Gi·ªù ngh·ªâ ng∆°i!';
                startBtn.textContent = 'B·∫Øt ƒë·∫ßu ngh·ªâ';
                if (Notification.permission === 'granted') {
                    new Notification("ƒê√£ h·∫øt gi·ªù t·∫≠p trung!", { body: "H√£y ngh·ªâ ng∆°i m·ªôt ch√∫t." });
                }
            } else {
                isFocusMode = true;
                timeLeft = focusTime;
                timerStatusEl.textContent = 'üéØ Th·ªùi gian t·∫≠p trung';
                startBtn.textContent = 'B·∫Øt ƒë·∫ßu l√†m';
                if (Notification.permission === 'granted') {
                    new Notification("H·∫øt gi·ªù ngh·ªâ!", { body: "Quay l·∫°i l√†m vi·ªác n√†o." });
                }
            }
            // Auto start next phase? Usually better to let user click start.
            // But standard Pomo apps sometimes auto-start. Let's wait for user input as currently implemented (pauseTimer called).

            // If we want auto-start next phase:
            // startTimer(); 
            // For now, let's keep it manual start for next phase or maybe just update display
            updateDisplay();

            // Unlock inputs? No, if we are in mid-session, we essentially just paused at 0.
            // Ideally we reset inputs only on full Reset.
        }

        function playSoundNotification() {
            const ctx = new (window.AudioContext || window.webkitAudioContext)();
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.connect(gain);
            gain.connect(ctx.destination);
            osc.type = 'sine';
            osc.frequency.setValueAtTime(440, ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(880, ctx.currentTime + 0.1);
            gain.gain.setValueAtTime(0.1, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.5);
            osc.start();
            osc.stop(ctx.currentTime + 0.5);
        }

        startBtn.addEventListener('click', toggleTimer);
        resetBtn.addEventListener('click', resetTimer);

        // Permissions
        if ("Notification" in window) {
            Notification.requestPermission();
        }


        // --- Audio Noise Logic ---
        let audioCtx;
        let noiseSource = null;
        let gainNode = null;
        let isPlayingSound = false;
        let currentNoiseType = null;

        const volumeSlider = document.getElementById('volumeSlider');
        const soundBtns = document.querySelectorAll('.sound-btn');

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                gainNode = audioCtx.createGain();
                gainNode.connect(audioCtx.destination);
                gainNode.gain.value = volumeSlider.value;
            }
        }

        function createWhiteNoise() {
            const bufferSize = 2 * audioCtx.sampleRate;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const output = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1;
            }
            return buffer;
        }

        function createPinkNoise() {
            const bufferSize = 2 * audioCtx.sampleRate;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const output = buffer.getChannelData(0);
            let b0, b1, b2, b3, b4, b5, b6;
            b0 = b1 = b2 = b3 = b4 = b5 = b6 = 0.0;
            for (let i = 0; i < bufferSize; i++) {
                const white = Math.random() * 2 - 1;
                b0 = 0.99886 * b0 + white * 0.0555179;
                b1 = 0.99332 * b1 + white * 0.0750759;
                b2 = 0.96900 * b2 + white * 0.1538520;
                b3 = 0.86650 * b3 + white * 0.3104856;
                b4 = 0.55000 * b4 + white * 0.5329522;
                b5 = -0.7616 * b5 - white * 0.0168980;
                output[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
                output[i] *= 0.11; // compensate to be roughly within -1 to 1
                b6 = white * 0.115926;
            }
            return buffer;
        }

        function createBrownNoise() {
            const bufferSize = 2 * audioCtx.sampleRate;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const output = buffer.getChannelData(0);
            let lastOut = 0;
            for (let i = 0; i < bufferSize; i++) {
                const white = Math.random() * 2 - 1;
                output[i] = (lastOut + (0.02 * white)) / 1.02;
                lastOut = output[i];
                output[i] *= 3.5; // compensate to be roughly within -1 to 1
            }
            return buffer;
        }

        function playNoise(type) {
            initAudio();
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }

            if (isPlayingSound) {
                noiseSource.stop();
            }

            // Unselect all btns
            soundBtns.forEach(btn => btn.classList.remove('active'));

            if (currentNoiseType === type && isPlayingSound) {
                // Clicking same button again -> Stop
                isPlayingSound = false;
                currentNoiseType = null;
                return;
            }

            // Start new sound
            const btn = document.querySelector(`.sound-btn[data-type="${type}"]`);
            if (btn) btn.classList.add('active');

            noiseSource = audioCtx.createBufferSource();
            let buffer;
            if (type === 'white') buffer = createWhiteNoise();
            else if (type === 'pink') buffer = createPinkNoise();
            else if (type === 'brown') buffer = createBrownNoise();

            noiseSource.buffer = buffer;
            noiseSource.loop = true;
            noiseSource.connect(gainNode);
            noiseSource.start();

            isPlayingSound = true;
            currentNoiseType = type;
        }

        soundBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                const type = btn.getAttribute('data-type');
                playNoise(type);
            });
        });

        volumeSlider.addEventListener('input', (e) => {
            if (gainNode) {
                gainNode.gain.value = e.target.value;
            }
        });

        // Initialize display
        updateDisplay();

    </script>
</body>

</html>